const minecraftCommand = require("../../contracts/minecraftCommand.js");
const { getLatestProfile } = require("../../../API/functions/getLatestProfile.js");
const getSkills = require("../../../API/stats/skills.js");
const getDungeons = require("../../../API/stats/dungeons.js");
const getWeight = require("../../../API/stats/weight.js");
const { formatUsername } = require("../../contracts/helperFunctions.js");


class BullyMeCommand extends minecraftCommand {
    constructor(minecraft) {
        super(minecraft);

        this.name = "bullyme";
        this.aliases = ["blameuser", "blameuserstats", "blame", "blamestats"];
        this.description = "Blame user for their stats.";
        this.options = [
            {
                name: "username",
                description: "Minecraft username",
                required: false,
            },
        ];

        // Configuration for thresholds
        this.thresholds = {
            skillAverage: 30,
            senitherW: 2000,
            catacombsLevel: 34,
            farming: 35,
            mining: 35,
            combat: 50,
            foraging: 60,
            fishing: 30,
            enchanting: 60,
            alchemy: 40,
            carpentry: 40,
            runecrafting: 20,
            social: 10,
            taming: 50,
        };

        // Array of possible blame messages
        this.blameMessages = [
            "Your ${stat} is too low! Stop beeing lazy!",
            "You need to work on your ${stat} u monke!",
            "Your ${stat} is not up to par! Get to work!",
            // Add more messages as needed
        ];
    } 

    // Function to get a random blame message
    getRandomBlameMessage(stat) {
        const randomIndex = Math.floor(Math.random() * this.blameMessages.length);
        return this.blameMessages[randomIndex].replace('${stat}', stat);
    }

    async onCommand(username, message) {
        try {
            username = this.getArgs(message)[0] || username;
            const data = await getLatestProfile(username);

            username = formatUsername(data.profileData?.displayname || username);

            const profile = getWeight(data.profile, data.uuid);
            const dungeons = getDungeons(data.playerRes, data.profile);
            const skills = getSkills(data.profile);

            const skillAverage = (
                Object.keys(skills)
                    .filter((skill) => !["runecrafting", "social"].includes(skill))
                    .map((skill) => skills[skill].levelWithProgress || 0)
                    .reduce((a, b) => a + b, 0) /
                (Object.keys(skills).length - 2)
            ).toFixed(2);

            const senitherW = profile.senither.total;
            const catacombsLevel = dungeons && 'catacombs' in dungeons && dungeons.catacombs && dungeons.catacombs.skill ? dungeons.catacombs.skill.levelWithProgress : 0;

            // Check if the user's stats are below the thresholds
            for (let stat in this.thresholds) {
                if (skills[stat] && skills[stat].levelWithProgress < this.thresholds[stat]) {
                    this.send(`/gc ${username}, ${this.getRandomBlameMessage(stat)}`);
                }
            }
        } catch (error) {
            console.error(error);
        }
    }
}